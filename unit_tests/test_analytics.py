#!/usr/bin/env python3
"""
Unit test for analytics endpoint output (table/chart data) and SQL produced by the server query.

Scenario:
- User: trial@example.com / trail123 (existing user with AI key configured)
- Dashboard: one dashboard with rent expenses in 2019
- Prompt: "Plot the rent for the months of 2019"

Validates:
- Response status and payload shape
- Returned data matches database totals for rent in 2019
- Prints the SQL generated by the server-side analytics query for visibility
"""

import os
import sys
import unittest
from datetime import date

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from app import app, db, parse_analytics_prompt  # noqa: E402
from models import User, Dashboard, DashboardMember, Expense  # noqa: E402
from sqlalchemy import func  # noqa: E402


class TestAnalyticsEndpoint(unittest.TestCase):
    def setUp(self):
        app.config['TESTING'] = True
        app.config['WTF_CSRF_ENABLED'] = False
        self.app = app.test_client()

        with app.app_context():
            user = User.query.filter_by(email='trial@example.com').first()
            if not user:
                raise unittest.SkipTest("Existing user trial@example.com not found; ensure DB is seeded with this user.")

            self.user_id = user.id

            # Create an isolated dashboard for this test under the existing user
            dashboard = Dashboard(
                name='Analytics Test Dashboard',
                description='Temp dashboard for analytics unit test',
                created_by=user.id
            )
            db.session.add(dashboard)
            db.session.commit()
            self.dashboard_id = dashboard.id

            # Membership (owner)
            member = DashboardMember(
                dashboard_id=dashboard.id,
                user_id=user.id,
                role='owner'
            )
            db.session.add(member)

            # Expenses: rent in 2019 (three months) + noise category
            expenses = [
                Expense(
                    dashboard_id=dashboard.id,
                    user_id=user.id,
                    date=date(2019, 1, 15),
                    description='January rent',
                    amount=100.00,
                    category='rent'
                ),
                Expense(
                    dashboard_id=dashboard.id,
                    user_id=user.id,
                    date=date(2019, 2, 15),
                    description='February rent',
                    amount=150.00,
                    category='rent'
                ),
                Expense(
                    dashboard_id=dashboard.id,
                    user_id=user.id,
                    date=date(2019, 3, 15),
                    description='March rent',
                    amount=200.00,
                    category='rent'
                ),
                Expense(
                    dashboard_id=dashboard.id,
                    user_id=user.id,
                    date=date(2021, 1, 10),
                    description='Groceries noise',
                    amount=50.00,
                    category='grocery'
                )
            ]
            db.session.add_all(expenses)
            db.session.commit()
            self._created_expense_ids = [e.id for e in expenses]
            self._member_id = member.id

    def tearDown(self):
        with app.app_context():
            # Clean up created data without dropping user or tables
            if getattr(self, "_created_expense_ids", None):
                Expense.query.filter(Expense.id.in_(self._created_expense_ids)).delete(synchronize_session=False)
            if getattr(self, "_member_id", None):
                DashboardMember.query.filter_by(id=self._member_id).delete()
            if getattr(self, "dashboard_id", None):
                Dashboard.query.filter_by(id=self.dashboard_id).delete()
            db.session.commit()

    def test_analytics_rent_2019(self):
        prompt = "Plot the rent for the months of 2019"

        # Simulate logged-in session
        with self.app.session_transaction() as sess:
            sess['user_id'] = self.user_id

        # Call analytics endpoint
        resp = self.app.post(
            f'/api/dashboard/{self.dashboard_id}/analytics/query',
            json={'prompt': prompt}
        )

        self.assertEqual(resp.status_code, 200, resp.get_data(as_text=True))
        data = resp.get_json()

        print(f"huh --> {data}")

        # Expected: bar trend by month, filtered to 2019 rent
        self.assertEqual(data['chart_type'], 'bar')
        self.assertEqual(data['labels'], ['2019-01', '2019-02', '2019-03'])

        # Compute expected sums per month from DB
        with app.app_context():
            expected_by_month = dict(
                db.session.query(
                    func.strftime('%Y-%m', Expense.date),
                    func.sum(Expense.amount)
                ).filter(
                    Expense.dashboard_id == self.dashboard_id,
                    func.strftime('%Y', Expense.date) == '2019',
                    func.lower(Expense.category) == 'rent'
                ).group_by(func.strftime('%Y-%m', Expense.date)).all()
            )

            # Capture SQL for debugging visibility
            parsed = parse_analytics_prompt(prompt)
            query = Expense.query.filter_by(dashboard_id=self.dashboard_id)
            if parsed['years']:
                query = query.filter(func.strftime('%Y', Expense.date).in_(parsed['years']))
            if parsed['category']:
                query = query.filter(func.lower(Expense.category) == parsed['category'].lower())
            sql_text = str(query.statement.compile(compile_kwargs={'literal_binds': True}))
            print("\n[Analytics SQL]", sql_text)

        self.assertEqual(len(data['data']), 3)
        returned = dict(zip(data['labels'], data['data']))
        for month, amount in expected_by_month.items():
            self.assertAlmostEqual(returned.get(month, 0), float(amount), places=2)
        self.assertIn('rent', data.get('summary', '').lower())


if __name__ == '__main__':
    unittest.main()
